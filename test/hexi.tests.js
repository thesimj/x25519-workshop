"use strict";

/**
 * Created by Mykola Bubelich
 * 2017-01-13
 */

const test = require("ava");
const Hexi = require("../src/hexi");

const t_vectors = {
    hex: [
        "00112233445566778899AABBCCDDEEFF",
        "112233445566778899AABBCCDDEEFF00",
        "2233445566778899AABBCCDDEEFF0011",
        "33445566778899AABBCCDDEEFF001122",
        "445566778899AABBCCDDEEFF00112233",
        "5566778899AABBCCDDEEFF0011223344",
        "66778899AABBCCDDEEFF001122334455",
        "778899AABBCCDDEEFF00112233445566",
        "8899AABBCCDDEEFF0011223344556677",
        "99AABBCCDDEEFF001122334455667788",
        "AABBCCDDEEFF00112233445566778899",
        "BBCCDDEEFF00112233445566778899AA",
        "CCDDEEFF00112233445566778899AABB",
        "DDEEFF00112233445566778899AABBCC",
        "EEFF00112233445566778899AABBCCDD",
        "FF00112233445566778899AABBCCDDEE",
    ],
    bytes: [
        new Uint8Array([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]),
        new Uint8Array([0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00]),
        new Uint8Array([0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11]),
        new Uint8Array([0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22]),
        new Uint8Array([0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33]),
        new Uint8Array([0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44]),
        new Uint8Array([0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55]),
        new Uint8Array([0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66]),
        new Uint8Array([0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77]),
        new Uint8Array([0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88]),
        new Uint8Array([0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99]),
        new Uint8Array([0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA]),
        new Uint8Array([0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB]),
        new Uint8Array([0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC]),
        new Uint8Array([0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD]),
        new Uint8Array([0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE]),
    ]
};

test("convert from string to hex", t => {
    for (let i = 0; i < t_vectors.hex.length; i++) {
        const hex = t_vectors.hex[i];
        const bytes = t_vectors.bytes[i];

        t.true(Hexi.equal(Hexi.hexToBytes(hex), bytes));
    }
});

test("convert from bytes to string", t => {
    for (let i = 0; i < t_vectors.hex.length; i++) {
        const hex = t_vectors.hex[i];
        const bytes = t_vectors.bytes[i];

        t.is(Hexi.bytesToHex(bytes).toUpperCase(), hex.toUpperCase());
    }
});

test("compare two bytes arrays should return true", t => {
    // compare equals
    for (const bytes of t_vectors.bytes) {
        t.true(Hexi.equal(bytes, bytes));
    }

    // compare not equals
    for (const bytes of t_vectors.bytes) {

        const two = new Uint8Array(bytes);
        two[0] = 0xAB;

        t.false(Hexi.equal(bytes, two));
    }
});

test("Errors should be thrown when hex string has not odd length", t => {
    t.throws(() => {
        Hexi.hexToBytes("000");
    }, Error);

    t.throws(() => {
        Hexi.hexToBytes("00000");
    }, Error);
});

test("Errors should be thrown when hex string not string type", t => {
    t.throws(() => {
        Hexi.hexToBytes(0);
    }, Error);

    t.throws(() => {
        Hexi.hexToBytes({});
    }, Error);
});